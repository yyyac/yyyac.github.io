# 滑动窗口

## 定长滑动窗口

!!! 套路
    1. 入：下标为$i$的元素进入窗口，更新相关统计量。如果$i<k-1$则重复第一步。
    2. 更新：更新答案。一般是最大值/最小值。
    3. 出：下标为$i-k+1$的元素离开窗口，更新相关统计量。

## 不定长滑动窗口

不定长滑动窗口主要分三类：求最长子数组，求最短子数组，以及求子数组个数。

### 求最长/最大

#### [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)

```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int ans = 0, l = 0;
        unordered_map<char, int> cnt;
        for(int r = 0; r < s.length(); r ++)
        {
            cnt[s[r]] ++;
            while(cnt[s[r]] > 1)
            {
                cnt[s[l]] --;
                l ++;
            }
            ans = max(ans, r - l + 1);
        }
        return ans;
    }
};
```

#### [长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums)
    {
        // int n = nums.size(), ans = n + 1, sum = 0, l = 0;
        // for(int r = 0; r < n; r ++)
        // {
        //     sum += nums[r];
        //     while(sum - nums[l] >= target)
        //         sum -= nums[l++];
        //     if(sum >= target)
        //         ans = min(ans, r - l + 1);
        // }
        // return ans <= n ? ans: 0;
        int ans = n + 1, sum = 0, l = 0;
        for(int r = 0; r < nums.size();  r++)
        {
            sum += nums[r];
            while(sum >= target)
            {
                ans = min(ans, l - r + 1);
                sum -= nums[l ++];
            }
        }
        return ans <= n ? ans : 0;
    }
};
```