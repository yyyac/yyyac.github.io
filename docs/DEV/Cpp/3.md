# 第三节 面向对象基础

## 访问修饰符 public 和 private

默认情况下，类的所有成员都是私有的，私有成员只能被该类的其他成员访问。但可以通过 public 关键字将它们设为共有。C++提供了 3 个不同的访问说明符关键字：public，private，protected。

**混合使用访问修饰符**

一般情况下，成员变量通常设为私有，成员函数通常设为共有：

```C++
#include <iostream>

class DateClass // members are private by default
{
private:
    int m_month {}; 
    int m_day {}; 
    int m_year {}; 

public:
    void setDate(int month, int day, int year) 
    {
        m_month = month;
        m_day = day;
        m_year = year;
    }

    void print() 
    {
        std::cout << m_month << '/' << m_day << '/' << m_year;
    }
};

int main()
{
    DateClass date;
    date.setDate(10, 14, 2020); 
    date.print(); 
    std::cout << '\n';

    return 0;
}
```

尽管不能在 main 中直接访问 m_month，m_day 和 m_year。但可以通过公有成员函数间接访问。类的公有成员的集合通常称为该类的公开接口。因为只有共有成员才能在类外被访问，所以公开接口实际上定义了程序应该如何使用接口和类进行交互。

**访问控制在类层面工作（而非对象层面）**

```c++
#include <iostream>

class DateClass 
{
    int m_month {}; 
    int m_day {}; 
    int m_year {}; 

public:
    void setDate(int month, int day, int year)
    {
        m_month = month;
        m_day = day;
        m_year = year;
    }

    void print()
    {
        std::cout << m_month << '/' << m_day << '/' << m_year;
    }

    
    void copyFrom(const DateClass& d)
    {
        m_month = d.m_month;
        m_day = d.m_day;
        m_year = d.m_year;
    }
};

int main()
{
    DateClass date;
    date.setDate(10, 14, 2020); 
    DateClass copy {};
    copy.copyFrom(date); 
    copy.print();
    std::cout << '\n';
    return 0;
}
```

访问控制是工作在类的层面，而不是对象层面。如果一个函数可以访问类中的某个私有成员，那么该类所有对象的该私有成员也都能被该函数放问。

`copyFrom()` 是成员函数，可以直接访问类的私有成员。因此该函数不仅可以访问调用它的对象，还可以直接访问它的形参（`Dateclass` 类型）的私有成员。

## 构造函数

类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数称为构造函数。只要类的对象被创建，就会执行构造函数。构造函数名字和类名相同，没有返回类型，可以重载，并且构造函数不能被声明为 const 的。

类通过一个特殊的函数来控制默认初始化过程，这个函数叫做模型构造函数。默认构造函数无须任何实参。如果类没有显式的定义构造函数，那么编译器会为我们隐式地定义一个默认构造函数。

编译器创建的构造函数又被称为合成的默认构造函数。对于大多数类来说，按照如下规则初始化类的数据成员：

- 如果存在类的初始值，则用它来初始化成员。
- 否则，默认初始化该成员。

### 定义 Sales_data 的构造函数

```c++
class Sacles_data
{
public:
    Sacles_data() = default;
    Sacles_data(const string &s) : bookNo(s) {}
    Sacles_data(const string &s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p * n) {}
    Sacles_data(istream &);
private:
    string bookNo;
    unsigned units_sold;
    double revenue;
};
```

`=default` 的含义。在 C++11 新标准中，如果需要默认的行为，那么可以通过在参数列表后面写上 `=default` 来要求编译器上传构造函数。其中 `=default` 既可以和声明一起出现在类的内部，则是内联的；也可以作为定义出现在类的外部，则不是内联的。

**初始值列表**

```C++
Sacles_data(const string &s) : bookNo(s) {}
Sacles_data(const string &s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p * n) {}
```

构造函数的初始值是成员名字的一个列表，每个名字后面紧跟括号的的是成员初始值。当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化。

**在类的外部定义构造函数**

以 istream 为参数的构造函数需要执行一些实际的操做。

```C++
Sales_data:: Sales_data(std::istream &is)
{
    read(is, *this)
}
```

## const 对象和成员函数

对于 const 类型的基本数据类，初始化可以通过拷贝初始化，直接初始化或统一初始化来完成：

```C++
const int a = 5 //拷贝初始化
const int a(5); //直接初始化
const int a {5}; //统一初始化
```

同样的，被实例化的对象也可以通过 const 关键字被创建为 cosnt 类型。初始化则是通过构造函数完成的：

```C++
const Date d; //使用默认构造函数初始化
const Date d2(2000,10,16)//使用带参构造函数初始化
const Date d3{2000,10,16}//使用带参构造函数初始化（c++11）
```

const 类型的对象，一旦通过构造函数初始化，其任何成员变量都不可再修改。不论是直接修改公有成员还是通过公有成员函数修改都是不可以的。

```C++
class Something
{
public:
    int m_value{};
    Something() : m_value(0) {}
    void setValue(int value) { m_value = value }
    int getValue() { return m_value; }
};

int main()
{
    const Something s;
    s.m_value = 1; //错误
    s.setValue(5); //错误
    system("pause");
    return 0;
}
```

上述涉及变量 s 的代码都是错误的，因为它们要么试图直接更改成员变量，要么调用试图更改成员变量的成员函数。

作为 const 类型的对象，只能显式地调用 const 类型的成员函数。const 成员函数是一类成员函数，并不会修改对象，也不会调用任何非 const 类型的成员函数（因为它们可能会修改对象）。

只需在函数参数列表后添加 const 关键字，就可将其声明为 cosnt 成员函数。此时它就可以被其他 cosnt 对象调用。

```C++
int getValue()const { return m_value; }
```

对于定义在类外的成员函数来说，不仅在类中声明时需要 const 关键字，类外定义时也需要。

> 构造函数不能被声明为 const，因为构造函数需要初始化成员变量。
> const 成员函数也可以由非 const 对象调用。

### 通过 const 类型引用传递 const 对象

```C++
class Date
{
private:
    int m_year {};
    int m_month {};
    int m_day {};

public:
    Date(int year, int month, int day)
    {
        setDate(year, month, day);
    }

    void setDate(int year, int month, int day)
    {
        m_year = year;
        m_month = month;
        m_day = day;
    }

    int getYear() { return m_year; }
    int getMonth() { return m_month; }
    int getDay() { return m_day; }
};

// 注意：我们通过传 const 引用来避免拷贝 data
void printDate(const Date& date)
{
    std::cout << date.getYear() << '/' << date.getMonth() << '/' << date.getDay() << '\n';
}

int main()
{
    Date date{2016, 10, 16};
    printDate(date);

    return 0;
}
```

这里的问题在于，在函数 printDate 函数中，date 被当做 const 对象，因此基于 const 对象 date 调用 getYear()、getMonth() 和 getDay()这些非 const 成员函数的时候，就会导致编译器报错。为了解决这个问题，需要将 getYear()、getMonth() 和 getDay() 定义为 const 即可。

### 可变数据成员

可以通过在变量的声明中加入 mutable 关键字，此时，const 成员函数也可以修改它。

一个可变数据成员永远不会是 const，即使它是 const 对象的成员。

```C++
class Something
{
public:
    mutable int m_value{};
    Something() : m_value(0) {}
    void setValue(int value) const { m_value = value; }
    int getValue() const { return m_value; }
};

int main()
{
    const Something s;
    s.setValue(20);
    s.m_value = 10;
    cout << s.m_value << endl;
    system("pause");
    return 0;
}
```

### const 成员不能返回非 const 引用成员

如果成员函数是 const 的，则 *this 指针也是 const 的，这就意味着在这个函数中，所有类成员都会被当做是 const 的。因此一个 const 成员函数不能返回非 const 引用成员。const 成员函数只能返回 const 引用成员。

## 静态成员变量

static关键字可以定义一个变量并确保它不会再离开作用域后被销毁。

## 友元

类可以允许其他类或者函数访问它的非公有成员：方法是令其他类或者函数成为它的友元，只需增加一条以 friend 关键字开始的函数声明语句即可。

```C++
class Sacles_data
{
friend Sacles_data add(const Sacles_data&, const Sacles_data&);
public:
    Sacles_data() = default;
    Sacles_data(const string &s) : bookNo(s) {}
    Sacles_data(const string &s, unsigned n, double p) : bookNo(s), units_sold(n), revenue(p * n) {}
    Sacles_data(istream &);
private:
    string bookNo;
    unsigned units_sold;
    double revenue;
};
```