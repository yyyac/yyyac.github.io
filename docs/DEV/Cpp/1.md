# 第一节 变量和基本类型

## 变量

```c++
//整形，4字节
int a = 100;
//ll整形，8字节
long long lla = 1000;
//长整型，4字节
long la = 1000;
//短整型，2字节
short a = 10;
//带符号字符整形
signed char sc = 'a';
//无符号字符整形
unsigned char uc = 'b';
//bool类型
bool b = true;
```

## 类型转换

把一种算术类型的值赋给另外一种类型。

```c++
bool b = 42; //b为真
int i = b; //i的值为1
i = 3.14; //i的值为3
double pi = i; //pi的值为3.0
unsigned char c = -1; //若char占8bit，则c的值为255，8bit可以表示0-255，若给定值超过此范围，实际的结果是该值对256取模后的余数
signed char c1 = 256; //若char占8bit，c2值是为定义的；复制给带符号类型一个超出其表示范围的值时，则结果是未定义的
//含无符号类型的表达式，当算数表达式中既有无符号整数又有int值时，就会把int值转化为无符号数
unsigned u = 10;
int i = -42;
cout << u + i << endl;
```

## 变量的声明和定义

C++中，变量的初始化和赋值是完全不同的操作。

```c++
int a = 10;
int a = {10};
//函数式声明初始化
int a(10);
//列表初始化
int a{10};
//但如果使用列表初始化且初始值存在信息丢失的风险，编译器将报错
long double id = 3.12421555
int a{id}; //报错，转换未执行，存在信息丢失风险
int a(id); //正确，转换执行，且丢失了部分值
```

用 extern 在头文件中声明，在 cpp 中定义，可以保证变量不被重复包含；若 extern 后面做了赋值操作，则不是声明而是定义。不带 extern，直接类型+变量名都是定义。

```c++
//只声明i
extern int i;
//声明并定义i
extern int i = 10;
//下述都为定义
int i;
int i = 10;
```

## 引用

在 C++中使用引用，可以让我们直接访问和操作另一个变量的内存地址，而无需通过指针的解引用操作。

```c++
int a = 100;
//定义引用b，并且指向a，此时b为a的别名
int &b = a;
```

定义引用后，对其进行的所有操作都是在与之绑定的对象上进行的。

```c++
//为引用赋值，实际上是把值赋给了与引用绑定的对象。
b = 2;
//相当于 int c = a;
int c = b;
```

### 特性

- 必须初始化：引用在创建时必须初始化，它必须与某个已存在的对象绑定。一旦绑定，不可改变。
- 除特殊情况外（const），所有的引用类型都要和与之绑定的对象严格匹配
- 引用必须绑定在某个对象上，没有空引用，也不能和字面值和表达式结果绑定在一起

### 注意事项

- 引用主要用于函数参数和返回值，以及类的成员变量等场景，以提供对原始数据的直接访问，从而提高程序的效率和可读性。
- 引用是可以 `const` 的，表示不能通过引用修改它所指向对象的值
- 引用在内部实现上通常是通过指针来实现的，但它们在语法和用途上与指针有显著的不同。引用提供了更直观、更安全的访问方式。

### 左值引用和右值引用

C++中，左值和右值是表达式的两种分类，它们决定了表达式的结果在内存中的位置个状态。左值通常指的是具有持久状态的对象，它们具有明确的内存地址，可以被多次赋值。而右值通常是临时的，通常没有内存地址，或者其内存地址在表达式结束后就变为无效。

## 指针

C++中，指针存储的是另一个变量的内存地址，而不是数据本身。通过使用指针，可以直接访问和操作内存中的数据。

### 和引用区别

- 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
- 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

```c++
int *p1, *p2; //p1，p2都是指向int型对象的指针
double d1, *d2; //d1是double类型对象，d2是指向double型对象的指针
```

指针本身也是对象，所以指针的地址可以用另一个指针变量存储，存储时需要二级指针。

```c++
int a = 10;
int* p1 = &a;
//p2存储的是指针p1的地址
int** p2 = &p1
```

### 类型匹配

除特例外，指针的类型必须和它所指的对象严格匹配。

```c++
double val = 3.14;
//初始值为double类型对象的地址
double *p1 = &val;
//初始值是指向double对象的指针
double *p2 = p1;
//错误，p的类型和p1不匹配
int *p = p1;
//错误，试图把double类型对象的地址赋值给int型指针
int *q = &val;
```

### 指针值

指针值应属下列 4 中状态之一：

1. 指向一个对象
2. 指向紧邻对象所占空间下一个位置
3. 空指针，没有指向任何对象
4. 无效指针

### 符号的多重含义

像&和*这样的符号，既能用作表达式里的运算符，也能作为声明的一部分出现，符号的上下文决定了符号的意义：

```c++
int a = 42;
//&紧跟着类型名出现，因此是声明的一部分，r是一个引用
int &r = a;
//*紧跟着类型名出现，是声明一部分，p是一个指针
int *p;
//&出现在表达式中，是取地址符号
p = &a;
//*出现在表达式中，是解引用符号
*p = a;
//&为声明一部分，*是解引用符号
int &r1 = *p;
```

### 空指针

包含以下几种定义方式：

```c++
//nullptr是一种特殊类型的字面值
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL;
```

### 指向指针的引用

引用本身不是对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用。

从右向左阅读 p2 的定义。离变量名最近符号对变量的类型有最直接的影响，因此 p2 是一个引用，*说明 p2 引用的是一个指针，最后声明的基本数据类型部分指出 p2 引用的是一个 int 指针。

```c++
int a = 42;
int b = 0;
int *p1 = &a;
int *&p2 = p1;
//p2引用了一个指针，因此给p2赋值就是令p1指向a
p2 = &b; 
```

### 指针运算

指针可以进行算术运算，如递增（++）和递减（--），这些操作会改变指针所指向的内存地址。但是，这种操作仅限于指向数组元素的指针。

在 C++中，数组名在表达式中通常被当作指向数组首元素的指针。

```c++
//指针可以进行算术运算，如递增（++）和递减（--），
// 这些操作会改变指针所指向的内存地址。但是，这种操作仅限于指向数组元素的指针。
int arr[5] = {1, 2, 3, 4, 5};
int *ptr_arr = arr;
std::cout << "ptr_arr is : " << ptr_arr << std::endl;
int firstElement = *ptr_arr;
std::cout << "firstElement is " << firstElement << std::endl;
// 递增指针
++ptr_arr; // ptr 现在指向 arr[1]
std::cout << "ptr_arr is : " << ptr_arr << std::endl;
// 访问新位置的值
int secondElement = *ptr_arr; // secondElement 等于 2
std::cout << "secondElement is " << secondElement;
```

上述程序输出

```c++
ptr_arr is : 0x3160fffa30
firstElement is 1
ptr_arr is : 0x3160fffa34
secondElement is 2
```

### 注意事项

- 指针必须在使用前被初始化，否则它们可能包含垃圾值，导致未定义行为。
- 指针运算（如递增和递减）仅适用于指向数组元素的指针。
- 指针的解引用操作必须确保指针不是空指针（nullptr），否则会导致运行时错误。

## const 限定符

### 定义与声明

`const` 是 C++中关键字，用于指示变量的值不可修改。

```c++
const int a = 10;
//可以用一个变量初始化常量，也可以将常量赋值给一个变量
int b = 1;
const int val = b;
int c = b;
```

### 编译器如何处理 const 修饰的变量

`const` 修饰的变量在编译时会被视为只读，尝试修改其值会导致编译错误。此外，编译器可能会对 `const` 变量进行优化，如将其存储在只读内存区域。

`const int bufSize = 512;`，编译器将在编译过程中把用到该变量的地方都替换成对应的值。默认情况下，const 对象被设定为仅在文件内有效。当多个文件中出现了同名的 const 变量时，其实等同于在不同文件中分别定义了独立的变量。

解决办法是，对于 `const` 变量不管是声明还是定义，都添加 extern 关键字，这样只需定义一次就可以了，并且可以在多个文件之间共享 `const` 对象。

## const 的引用

可以把引用绑定到 `const` 对象上，就像绑定到其他对象上一样，我们称之为对常量的引用。与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象：

```c++
const int ci = 100;
//用常量引用绑定常量对象
const int &r1 = ci;
//不能通过r1修改ci的值
r1 = 2;
//也不能用非常量引用指向一个常量对象
int &r2 = ci;
```

**初始化和对 cosnt 的引用**

引用的类型与其所引用对象的类型必须一致，但有两个特例。第一种就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转化成引用类型即可。允许将 `const` 引用绑定一个非 const 变量，也可绑定字面量以及表达式的值。

```c++
int a = 10;
const int &r1 = a;
const int &r2 = 100;
const int &r3 = r2 * 2;
double b = 3.14;
const int &ref = b;
```

上述代码相当于

```c++
const int temp = b; //由双精度浮点数生成一个临时的整型常量
const int &ref = temp;
```

这种情况下，ref 绑定了一个临时对象，所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。

对 `const` 的引用可能引用一个并非 `const` 的对象必须认识到，常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值：

```c++
int a = 10;
const int &r1 = a;
int &r2 = a;
r2 = 11;
```

## 指针和 const

### 指向常量的指针

存放常量对象的地址，只能使用指向常量的指针，不能用于改变其所指对象的值。

```c++
const int a = 100;
//错误，q是一个普通指针
int *q = &a;
const int *p = &a;
//错误，不能给*p赋值
*p = 10;
```

指针的类型必须与其所指对象的类型一致，但是允许令一个指向常量的指针指向一个非常量对象。
```c++
double b = 3.14;
const double *p = &b;
```

### const 指针

指针是对象，而引用不是，所以允许把指针本身定为常量。常量指针必须初始化，一旦初始化完成，则它的值（即存放在指针中的地址）就不能再改变了。把*放在 `const` 之前用以说明指针是一个常量，即不变的是指针本身的值而非指向的那个值。

```c++
int a = 0;
//p是一个常量指针
int *const p = &a;
const double pi = 3.14;
//q是一个指向常量对象的常量指针
const double *const q = &pi;
//可以修改常量指针指向的内容
*p = 20;
```

## 顶层 const

指针本身是一个对象，它又可以指向另外一个对象。因此，指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。

用名词顶层 `const`（top-level const）表示指针本身是个常量，而用名词底层 `const`（low-level const）表示指针所指的对象是一个常量。

顶层 `const` 可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。

底层 `const` 则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层 `const` 也可以是底层 `const`，这一点和其他类型相比区别明显：

```c++
int i = 0;
//不能改变pi的值，为顶层const
int *const pi = &i;
//不能改变ci的值，为顶层const 
const int ci = 42;
//允许改变p2的值，为底层const
const int *p2 = &ci;
//靠右边的const是顶层const，靠左边的const是底层const
const int * const p3 = p2;
//用于声明引用的const都是底层const
const int &r = i;
```

底层 `const` 的限制却不能忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层 `const` 资格，或者两个对象的数据类型必须能够转换，一般来说，非常量可以转换为常量，反之不行。

## constexpr 和常量表达式

常量表达式是指值不会改变且在编译过程就能得到计算结果的表达式。比如，字面值属于常量表达式，用常量表达式初始化的 const 对象也是常量表达式。

```c++
//max_files和limit都是常量表达式
const int max_files = 20;
const int limit = max_files + 1;
//无const声明，不是常量表达式
int a = 20;
//sz不是常量表达式，运算时才得知
const int sz = Getsize();
```

C++11 新标准规定，允许将变量声明为 constexpr 类型，以便编译器来验证变量是否为常量表达式。声明为 constexpr 的变量一定是一个常量，而且必须用常量表达式初始化。

```c++
constexpr int mf = 20;
constexpr int limit = mf + 1;
//只有当size()是一个constexpr函数时，才是一条正确的声明语句
constexpr int sz = size();
constexpr int size(){
    return 1;
}
```

## 指针和 constexpr

在 constexpr 声明中定义了指针，则 constexpr 仅对指针有效，与指针所指对象无关。

```c++
//p是指向整型常量的指针
const int *p = nullptr;
//q是常量指针
constexpr int *q = nullptr;
```

constexpr 指针的初始值必须为 nullptr 或 0，或存储于某个固定地址中的对象。故 constexpr 指针不能指向函数体内部定义的变量；但可以指向全局变量。